+++
date = '2025-10-13T20:54:11+08:00'
draft = false
title = 'Go语言中的数组以及切片'
summary = 'Go 语言中的数组以及切片语法记录'
categories = [ 'go' ]
tags = [ 'go' ]
+++

## 🧩 一、数组（Array）

### 1. 基本概念
- 数组是 **固定长度** 的、**同类型元素** 的序列。
- 数组的长度是类型的一部分，长度不同就是不同的类型。

```go
var a [3]int               // [0 0 0]
b := [3]int{1, 2, 3}       // [1 2 3]
c := [...]int{1, 2, 3, 4}  // 自动推断长度为4
```

### 2. 特点
- **长度固定**
- **值类型**（赋值或传参会复制整个数组）
- **类型不同**
- 可通过 `len()` 获取长度。

```go
func f(arr [3]int) {
    arr[0] = 999
}
a := [3]int{1, 2, 3}
f(a)
fmt.Println(a) // [1 2 3]
```

### 3. 多维数组
```go
var matrix [2][3]int = [2][3]int{
    {1, 2, 3},
    {4, 5, 6},
}
```

---

## 🌱 二、切片（Slice）

### 1. 基本概念
切片是对数组的 **动态视图**。
底层结构：

```go
type slice struct {
    ptr *T
    len int
    cap int
}
```

### 2. 定义方式

```go
// 基于数组
arr := [5]int{1, 2, 3, 4, 5}
s := arr[1:4] // [2 3 4]

// 使用 make
s := make([]int, 3, 5)

// 字面量定义
s := []int{10, 20, 30}
```

### 3. 常用操作

| 操作 | 示例 | 说明 |
|------|------|------|
| 长度 | `len(s)` | 元素数量 |
| 容量 | `cap(s)` | 底层数组容量 |
| 追加 | `s = append(s, 4)` | 自动扩容 |
| 再切 | `s2 := s[1:3]` | 共用底层数组 |
| 拷贝 | `copy(dst, src)` | 拷贝最短部分 |

```go
s := []int{1, 2, 3}
s = append(s, 4)
t := s[1:3]
copy(t, []int{9, 9})
fmt.Println(s) // [1 9 9 4]
```

---

## ⚙️ 三、数组 vs 切片

| 对比项 | 数组 | 切片 |
|--------|------|------|
| 长度 | 固定 | 可变 |
| 是否引用类型 | 否 | 是 |
| 拷贝行为 | 全部复制 | 仅复制结构体头 |
| 零值 | `[0 0 0]` | `nil` |
| 扩容 | 否 | 是 |

---

## 🧠 四、切片扩容机制

`append()` 时若容量不足：
1. 分配新数组
2. 拷贝旧数据
3. 更新引用

### 扩容策略（Go 1.18 起）
- <1024 元素 → 扩容为原来的2倍
- ≥1024 元素 → 扩容约1.25倍

```go
s := []int{}
for i := 0; i < 10; i++ {
    s = append(s, i)
    fmt.Printf("len=%d cap=%d\n", len(s), cap(s))
}
```

---

## ⚠️ 五、常见坑点

1. **切片共享底层数组**
```go
a := []int{1, 2, 3, 4}
b := a[1:3]
b[0] = 9
fmt.Println(a) // [1 9 3 4]
```

2. **append 扩容导致新数组**
```go
a := []int{1, 2, 3}
b := a[:2]
b = append(b, 99)
fmt.Println(a) // [1 2 3]
fmt.Println(b) // [1 2 99]
```

3. **nil 切片 vs 空切片**
```go
var s1 []int
s2 := []int{}
fmt.Println(s1 == nil) // true
fmt.Println(s2 == nil) // false
```

---

## 💡 六、最佳实践

| 场景 | 推荐 |
|------|------|
| 固定数量 | 数组 |
| 动态数据 | 切片 |
| 传参 | 切片 |
| 防止影响原数据 | copy |

**优化建议：**
- 预分配容量：`make([]T, 0, n)`
- 修改前确认是否共享底层
- 不直接比较切片内容（用 `reflect.DeepEqual`）

