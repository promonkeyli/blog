+++
date = '2025-11-11T20:59:47+08:00'
draft = false
title = '数据库(关系型)设计最佳实践'
summary = '总结关系型数据库设计最佳实践'
categories = [ 'database' ]
tags = [ 'database' ]
+++

> 本文总结数据库表结构设计中的核心原则与经验，适用于 MySQL、PostgreSQL 等关系型数据库。

---

## 一、整体设计思路

1. **以业务为导向**：设计应服务于业务场景，而非数据库功能本身。
2. **从实体出发**：先定义核心实体（如用户、订单、商品），再明确它们之间的关系（如一对多、多对多）。
3. **结构清晰、便于扩展**：避免过度抽象或过度冗余。

---

## 二、命名规范

| 类型 | 规范 |
|------|------|
| 数据库名 | 全小写，下划线分隔，例如 `shop_system` |
| 表名 | 单数形式，全小写，如 `user`、`order` |
| 字段名 | 全小写，下划线分隔，如 `created_at`、`user_id` |
| 外键 | 命名为 `{关联表名}_id`，如 `user_id` |
| 枚举/状态字段 | 命名为 `{对象}_status`，如 `order_status` |

> ⚠️ 避免使用保留字，如 `order`、`desc`、`user` 等。

---

## 三、字段设计原则

### 1️⃣ 每个字段只存一类信息
- ❌ `address` 存完整地址（不便于搜索）
- ✅ 拆分为 `province`, `city`, `district`, `detail`

### 2️⃣ 字段类型选择精准

| 类型 | 场景 | 示例 |
|------|------|------|
| `INT UNSIGNED` | ID、自增字段 | `id` |
| `VARCHAR(255)` | 字符串 | `name`、`email` |
| `TEXT` | 长文本（慎用，不可索引） | `content` |
| `DATETIME` | 时间点 | `created_at` |
| `TINYINT` | 小枚举 | `status` |
| `DECIMAL(10,2)` | 金额 | `price`、`amount` |

> ⚠️ 不建议随意使用 `TEXT`、`JSON` 存复杂结构，影响查询性能。

---

## 四、主键与外键设计

### 主键
- 推荐使用 **自增 ID** 或 **雪花 ID / UUID**。
- 主键命名统一为 `id`。

### 外键
- **不建议使用数据库外键约束**，在应用层保证数据一致性。
- 优点：迁移方便，性能更好。

---

## 五、时间字段规范

| 字段 | 含义 | 建议 |
|------|------|------|
| `created_at` | 创建时间 | 默认 `CURRENT_TIMESTAMP` |
| `updated_at` | 更新时间 | `ON UPDATE CURRENT_TIMESTAMP` |
| `deleted_at` | 软删除标记 | `NULL` 表示未删除 |

> 💡 软删除优于状态字段删除，可保留数据记录。

---

## 六、状态与枚举字段

使用整型（`TINYINT`）或字符串（`ENUM`）存储状态。  
同时记录清晰注释或定义常量表。

```sql
order_status TINYINT NOT NULL DEFAULT 0 COMMENT '订单状态：0待支付 1已支付 2已发货 3已完成'
```

---

## 七、索引设计原则

### 1️⃣ 主键索引
每个表必须有主键。

### 2️⃣ 普通索引
为高频查询字段创建索引：
```sql
CREATE INDEX idx_user_id ON order(user_id);
```

### 3️⃣ 组合索引
对联合查询常用字段建立复合索引：
```sql
CREATE INDEX idx_user_status ON order(user_id, order_status);
```

> ⚠️ 索引太多会降低写入性能，只为高频查询添加。

---

## 八、范式与反范式

| 设计模式 | 特点 | 适用场景 |
|-----------|------|----------|
| **第三范式 (3NF)** | 减少冗余 | 高并发、事务系统 |
| **反范式** | 增加冗余以提升查询效率 | 报表、统计场景 |

💡 实践建议：
> 用户名可冗余存储在订单表中，以减少联表查询。

---

## 九、唯一约束与默认值

- 对关键业务字段添加唯一约束：
  ```sql
  UNIQUE KEY uq_email (email)
  ```
- 合理设置默认值，避免过多 `NULL`（除非有意义）。
- 对布尔型字段使用 `TINYINT(1)` 并设置默认值。

---

## 十、表结构变更管理

1. 使用 **数据库迁移工具**（如 Flyway、Liquibase、Goose）。
2. 每次变更都应生成版本文件，不直接在生产库修改。
3. 建议保留历史版本以便回滚。

---

## 十一、示例：用户 + 订单系统

```sql
CREATE TABLE user (
  id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(50) NOT NULL,
  email VARCHAR(100) NOT NULL UNIQUE,
  password_hash CHAR(60) NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

CREATE TABLE `order` (
  id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT UNSIGNED NOT NULL,
  total_amount DECIMAL(10,2) NOT NULL DEFAULT 0.00,
  order_status TINYINT NOT NULL DEFAULT 0 COMMENT '0待支付 1已支付 2已完成',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_user_id (user_id)
);
```

---

## 十二、附录：常见设计陷阱

| 错误做法 | 问题 | 正确做法 |
|-----------|------|-----------|
| 过度拆分表 | 查询复杂、性能低 | 适度合并，兼顾可维护性 |
| 无索引大表 | 查询极慢 | 添加索引或分表 |
| 滥用外键 | 锁表、影响性能 | 应用层维护关系 |
| 使用 TEXT 存结构化数据 | 无法查询 | 拆字段或单独表 |
| 无 created_at | 无法追踪 | 所有表均应有时间字段 |

---

## ✅ 总结

**设计良好的数据库结构** 应满足以下条件：

- 命名清晰一致
- 字段类型精准
- 合理索引
- 明确时间与状态字段
- 支持扩展与迁移

> 🧠 *“表结构就是系统的骨架，设计得好，系统才能长久稳定。”*
